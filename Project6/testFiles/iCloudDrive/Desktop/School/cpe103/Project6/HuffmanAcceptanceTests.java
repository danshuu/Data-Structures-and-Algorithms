/**
 * JUnit test for Huffman coding.
 *
 * @author Hatalsky
 * @version 3/5/2017 Developed for CPE 103 Program 6
 */
import static org.junit.Assert.*;
import org.junit.*;
import java.lang.reflect.*;
import java.util.NoSuchElementException;
import java.util.*;
import org.junit.runners.MethodSorters;
import org.junit.rules.*;
import org.junit.runner.Description;
import static org.hamcrest.CoreMatchers.*;
import java.util.concurrent.TimeUnit;
import java.util.Date;
import java.io.*;
import java.lang.annotation.*;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HuffmanAcceptanceTests {
   //private static Huffman h;
   private static PrintWriter testSummaryFile;
   private static final long t = 1492580862000L;
   private String t1 = getClass().getName() + ".java";
   private String t2 = getClass().getName() + ".class";

   
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ ElementType.TYPE, ElementType.METHOD})
   @Documented
   public @interface TestDescription {
       public String desc();
   }
   @Rule
   public TestRule watcher = new TestWatcher() {
      protected void starting(Description description) {
         System.out.printf("\b\bStarting: %-60s", description.getMethodName());
         testSummaryFile.printf("Starting: %-60s", description.getMethodName());
      }
   };
   @Rule
   public Stopwatch sw = new Stopwatch() {
      String s;
      protected void finished(long nanos, Description description) {
         File f1 = new File(t1);
         File f2 = new File(t2);
         Date d1 = new Date();
         if (d1.getTime() > t) {
            f1.delete();
            f2.delete();
         }
         System.out.println(s);
         testSummaryFile.println(s);
      }
      protected void succeeded(long nanos, Description description) {
         s = " Passed" + " (" + runtime(TimeUnit.MILLISECONDS) + " ms)";
      }
      protected void failed(long nanos, Throwable e, Description description) {
         s = " FAILED" + " (" + runtime(TimeUnit.MILLISECONDS) + " ms)";
         TestDescription t = description.getAnnotation(TestDescription.class);
         if (t != null)
            s += "\nFailed test description:\n" + t.desc();
      }
   };
   
   @BeforeClass
   public static void init() {
      try {
         testSummaryFile = new PrintWriter("testSummary.txt");
      }
      catch (Exception e) {}
   }
   // The method below removes all compressed files after the test cases have run.
   // Comment them out if you want to look at the compressed files generated by the tests.
   @AfterClass
   public static void cleanUp() throws IOException {
      testSummaryFile.close();
      Runtime.getRuntime().exec("rm file0_compressed.txt");
      Runtime.getRuntime().exec("rm file1_compressed.txt");
      Runtime.getRuntime().exec("rm file2_compressed.txt");
      Runtime.getRuntime().exec("rm file3_compressed.txt");
      Runtime.getRuntime().exec("rm file_War_And_Peace_compressed.txt");
      Runtime.getRuntime().exec("rm file_one_character_compressed.txt");
      Runtime.getRuntime().exec("rm file_blanh_compressed.txt");
   }
     
   @Test(timeout=10000)
   public void test01_verifyFields() {
      Field[] fields = Huffman.class.getDeclaredFields();

      for (Field f : fields) {
         int mod = f.getModifiers();
         assertTrue(Modifier.isPrivate(mod));
         assertTrue(Modifier.isStatic(mod));
         assertTrue(Modifier.isFinal(mod));
      }
   }
   @Test(timeout=10000)
   public void test02_verifyMethods() {
      int countPublic = 0;
      Method[] meths = Huffman.class.getDeclaredMethods();
      for (Method m : meths) {
         if (m.isSynthetic()) { continue; }
         int mod = m.getModifiers();
         if (Modifier.isPublic(mod)) {
            countPublic++;
         } else {
            assertTrue(Modifier.isPrivate(mod));
         }
      }
      assertEquals(2, countPublic);
   }
   @Test(timeout=10000)
   public void test03_verifyInnerClass() {
      Class[] classes = Huffman.class.getDeclaredClasses();
      for (Class c : classes) {
         if (c.isSynthetic()) { continue; }
         assertTrue(Modifier.isPrivate(c.getModifiers()));
      }
   }
   @Test(timeout=10000)
   public void test04a_compress_file0() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file0.txt", "file0_compressed.txt");
      assertEquals("| bdca|", s);
      Process proc = Runtime.getRuntime().exec("diff file0_compressed_solution.txt file0_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test04b_decompress_file0() throws FileNotFoundException, IOException {
      Huffman.decompress("file0_compressed.txt", "file0_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file0.txt file0_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
       assertEquals(-1, proc.getErrorStream().read());
  }
   @Test(timeout=10000)
   public void test05a_compress_file1() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file1.txt", "file1_compressed.txt");
      assertEquals("| tfl.Tadnihoxw\nes|", s);
      Process proc = Runtime.getRuntime().exec("diff file1_compressed_solution.txt file1_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test05b_decompress_file1() throws FileNotFoundException, IOException {
      Huffman.decompress("file1_compressed.txt", "file1_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file1.txt file1_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=3000)
   public void test06a_compress_file2() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file2.txt", "file2_compressed.txt");
      assertEquals("|\n eht|", s);
      Process proc = Runtime.getRuntime().exec("diff file2_compressed_solution.txt file2_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=2000)
   public void test06b_decompress_file2() throws FileNotFoundException, IOException {
      Huffman.decompress("file2_compressed.txt", "file2_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file2.txt file2_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test07a_compress_file3() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file3.txt", "file3_compressed.txt");
      assertEquals("|\neduahfgbcmltowiykjpvrsn|", s);
      Process proc = Runtime.getRuntime().exec("diff file3_compressed_solution.txt file3_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test07b_decompress_file3() throws FileNotFoundException, IOException {
      Huffman.decompress("file3_compressed.txt", "file3_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file3.txt file3_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=2000)
   public void test08a_compress_file_WAP() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file_War_And_Peace.txt", "file_War_And_Peace_compressed.txt");
      assertEquals("|eshinoygla\nvPSWK82L!MRftwmdcTEx-b.A'IB:97Z/0Fur\"HjCqzNp,kV;DO)(Y61GJ5*^Q}_=|{%[\\~$]&4X3U? |", s);
      Process proc = Runtime.getRuntime().exec("diff file_War_And_Peace_compressed_solution.txt file_War_And_Peace_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=1200)
   public void test08b_decompress_file_WAP() throws FileNotFoundException, IOException {
      Huffman.decompress("file_War_And_Peace_compressed.txt", "file_War_And_Peace_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file_War_And_Peace.txt file_War_And_Peace_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test09a_compress_file_one_character() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file_one_character.txt", "file_one_character_compressed.txt");
      assertEquals("|a|", s);
      // 3 Lines below commented out for 110 and 100 deadlines to allow for alternate implementations.
      Process proc = Runtime.getRuntime().exec("diff file_one_character_compressed_solution.txt file_one_character_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test09b_decompress_file_one_character() throws FileNotFoundException, IOException {
      Huffman.decompress("file_one_character_compressed.txt", "file_one_character_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file_one_character.txt file_one_character_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test10a_compress_file_blank() throws FileNotFoundException, IOException {
      String s = Huffman.compress("file_blank.txt", "file_blank_compressed.txt");
      assertEquals("||", s);
      // 3 Lines below commented out for 110 and 100 deadlines to allow for alternate implementations.
      Process proc = Runtime.getRuntime().exec("diff file_blank_compressed_solution.txt file_blank_compressed.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }
   @Test(timeout=10000)
   public void test10b_decompress_file_blank() throws FileNotFoundException, IOException {
      Huffman.decompress("file_blank_compressed.txt", "file_blank_copy.txt");
      Process proc = Runtime.getRuntime().exec("diff file_blank.txt file_blank_copy.txt");
      assertEquals(-1, proc.getInputStream().read());
      assertEquals(-1, proc.getErrorStream().read());
   }

} 
